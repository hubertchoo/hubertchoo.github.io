<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Hubert Choo</title><link>https://hubertchoo.github.io/posts/</link><description>Recent content in Posts on Hubert Choo</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Wed, 05 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://hubertchoo.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>FPGA Video Denoising and Segmentation (Y2 Summer Project)</title><link>https://hubertchoo.github.io/posts/2023/07/fpga-video-denoising-and-segmentation-y2-summer-project/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://hubertchoo.github.io/posts/2023/07/fpga-video-denoising-and-segmentation-y2-summer-project/</guid><description>Y2 Summer Project Introduction For the Imperial EEE Department, the Y2 Summer Term project was to:
Design and build a balancing rover (Segway), that can autonomously navigate and map a maze, with the assistance of three beacons. Finally, the shortest path through the maze should be computed and followed. A prototype of the design must be built and tested on the artificial maze in the lab. The maze is laid out with light strips on an arena.</description><content type="html"><![CDATA[<h2 id="y2-summer-project-introduction">Y2 Summer Project Introduction</h2>
<p>For the Imperial EEE Department, the Y2 Summer Term project was to:</p>
<ol>
<li>Design and build a balancing rover (Segway),</li>
<li>that can autonomously navigate and map a maze,</li>
<li>with the assistance of three beacons.</li>
<li>Finally, the shortest path through the maze should be computed and followed.</li>
</ol>
<p>A prototype of the design must be built and tested on the artificial maze in the lab. The maze is laid out with light strips on an arena. The arena is coloured black and surrounded by black curtains.</p>
]]></content></item><item><title>My Boards and My Software</title><link>https://hubertchoo.github.io/posts/2023/07/my-boards-and-my-software/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://hubertchoo.github.io/posts/2023/07/my-boards-and-my-software/</guid><description>The FPGA Boards I Use DE10-Lite MAX10 10M50DAF484C7G Device DE10-Nano Intel Cyclone® V SE 5CSEBA6U23I7 device 800MHz Dual-core ARM Cortex-A9 hard processor The Daughter Boards I Use D8M-GPIO 8 Mega Pixel Digital Camera Package with GPIO interface The Software I Use Quartus Prime Lite 18.1 NIOS II Embedded Design Suite (EDS) ModelSim - Intel FPGA Starter Edition 10.5b</description><content type="html"><![CDATA[<h2 id="the-fpga-boards-i-use">The FPGA Boards I Use</h2>
<ol>
<li><a href="https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;No=1021">DE10-Lite</a></li>
</ol>
<ul>
<li>MAX10 10M50DAF484C7G Device</li>
</ul>
<ol start="2">
<li><a href="https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;CategoryNo=167&amp;No=1046">DE10-Nano</a></li>
</ol>
<ul>
<li>Intel Cyclone® V SE 5CSEBA6U23I7 device</li>
<li>800MHz Dual-core ARM Cortex-A9 hard processor</li>
</ul>
<h2 id="the-daughter-boards-i-use">The Daughter Boards I Use</h2>
<ol>
<li><a href="https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;No=1011">D8M-GPIO</a></li>
</ol>
<ul>
<li>8 Mega Pixel Digital Camera Package with GPIO interface</li>
</ul>
<h2 id="the-software-i-use">The Software I Use</h2>
<ol>
<li><a href="https://www.intel.com/content/www/us/en/software-kit/665990/intel-quartus-prime-lite-edition-design-software-version-18-1-for-windows.html">Quartus Prime Lite 18.1</a></li>
</ol>
<ul>
<li>NIOS II Embedded Design Suite (EDS)</li>
<li>ModelSim - Intel FPGA Starter Edition 10.5b</li>
</ul>
]]></content></item><item><title>Setting Up This Website</title><link>https://hubertchoo.github.io/posts/2023/07/setting-up-this-website/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://hubertchoo.github.io/posts/2023/07/setting-up-this-website/</guid><description>Step 1. Install Hugo, Go, Dart Sass Go to Hugo Installation and download the appropriate version for your OS and architecture.
I used the Winget Packet Manager to install the Hugo Extended Edition.
winget install Hugo.Hugo.Extended Step 2. Set Up Github Pages with Hugo Follow this guide to set up Github Pages for use with Hugo.
A Github Action is also set up to deploy the website automatically with new pushes.</description><content type="html"><![CDATA[<h2 id="step-1-install-hugo-go-dart-sass">Step 1. Install Hugo, Go, Dart Sass</h2>
<p>Go to <a href="https://gohugo.io/installation/">Hugo Installation</a> and download the
appropriate version for your OS and architecture.</p>
<p>I used the Winget Packet Manager to install the Hugo Extended Edition.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>winget install Hugo.Hugo.Extended
</span></span></code></pre></div><h2 id="step-2-set-up-github-pages-with-hugo">Step 2. Set Up Github Pages with Hugo</h2>
<p>Follow this <a href="https://carpentries-incubator.github.io/blogging-with-hugo-and-github-pages/02-locally-setup-hugo/index.html">guide</a> to set up Github Pages for use with Hugo.</p>
<p>A Github Action is also set up to deploy the website automatically with new pushes.</p>
<p>The Hugo theme <a href="https://github.com/rhazdon/hugo-theme-hello-friend-ng">Hello Friend NG</a> is used. Configuration settings for the Hugo theme is also in the link.</p>
<h2 id="step-3-creating-a-new-post">Step 3. Creating a New Post</h2>
<p>Create a new md file in the directory /posts/___.md.</p>
<h2 id="step-4-preview-the-website-before-pushing">Step 4. Preview the Website Before Pushing</h2>
<p>Do</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>hugo server
</span></span></code></pre></div>]]></content></item><item><title>What Do I Learn To Be An FPGA Engineer?</title><link>https://hubertchoo.github.io/posts/2023/07/what-do-i-learn-to-be-an-fpga-engineer/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://hubertchoo.github.io/posts/2023/07/what-do-i-learn-to-be-an-fpga-engineer/</guid><description>How Do I Break Into The FPGA Industry? That is the title of this Reddit thread. One of the top comments mention the following:
In no particular order. FPGA - Learn to write either Verilog, SystemVerilog or VHDL, the ones you don't know how to write, at least know how to read. - Know the existence of new HDLs like SpinalHDL, Chisel, Amaranth, Bluespec-SV, etc. You do not necessarily have to know or use them, but know they exist and why.</description><content type="html"><![CDATA[<h2 id="how-do-i-break-into-the-fpga-industry">How Do I Break Into The FPGA Industry?</h2>
<p>That is the title of <a href="https://www.reddit.com/r/FPGA/comments/11ufijp/how_do_i_break_into_the_fpga_industry/">this Reddit thread</a>. One of the top comments mention the following:</p>
<pre><code>In no particular order.

FPGA
    - Learn to write either Verilog, SystemVerilog or VHDL, the ones you don't know how to write, at least know how to read.
    - Know the existence of new HDLs like SpinalHDL, Chisel, Amaranth, Bluespec-SV, etc. You do not necessarily have to know or use them, but know they exist and why.
    - Learn to use standardized memory busses, this includes AXI, AXI-Lite, Avalon, Wishbone, AHB, APB. You do not need to know all of them, you just need to know some of them well and you should know the others exist.
    - Learn to use standardized streaming busses, this is basically AXI-Stream or similar.
    - Know when and how to do a clock domain crossing.
    - Learn to follow common design patterns that use reusable modules, such as FIFOs, switches, muxes, header/footer extraction (from streams), CRC checkers, pattern generators, pattern checkers, bus adapters, etc.
    - Learn to write IO and timing constraints, know what set_output_delay and set_input_delay does, what set_false_path does, what set_clock_group does.
    - Learn to use similar/same internal interfaces for different external interfaces, UART, Ethernet, SpaceWire, Aurora, CAN, etc can all use the same internal interface as each other
    - Learn to write self checks into your code so stuff cannot be parameterized into a mode that you did not test or is not a valid configuration.
    - Learn to bring up a high speed serial transceiver for SATA, JESD, PCIe, high speed Ethernet, SpaceWire, etc.
    - Learn to interact with external memory through vendor provided IP (Xilinx DDR MIG, or whatever)

Verification
    - Learn to simulate more, just in general. I don't care which tool.
    - If you plan on going into ASIC or big FPGA companies, learn something like UVM, else learn something like VUnit or CocoTB if you want to work on small teams.
    - Learn to use a traditional simulator and the open source stuff like Verilator which has some specific use cases where it wins, hard.
    - Learn to write bus functional models to allow for module and system level simulation where you have to interact with an external component.
    - Learn to write simulation bus drivers with internal self checks.

Tool Automation
    - For all of the above, learn to script your tools for commonly done tasks, project generation, build modifications, etc.
    - Learn to develop tools that keep your work across domains/tools in sync, register maps, configuration management, etc
        - systemrdl-compiler/peakrdl or Questa Register Check for registers
        - Learn to write tools that can take HDL files with your own syntax added and use the file as a template to generate custom code for a specific project
        - Learn how to write HLS tools, not just use them. Often it makes sense to use your own custom HLS for something particularly repetitive but different enough between boards/projects.

FPGA/Verification/Software
    - Learn to use Git, Subversion, Perforce. One source control system, please, anything but random files in folders or zip files.
    - Learn to automate build/test flows, learn GitHub Actions, or Jenkins, or GitLab CI
    - Learn to build consistent environments, maybe use Docker or similar.
    - Learn to use linters and static code analysis tools.
        - FPGA/Verification: SVLint, CDC Linters, Reset Domain Linters, etc.
        - Software: CppLint, PyLint, etc.
    - Learn to use document generators for all your languages

Software
    - Learn to write enough C/C++, Python, or whatever that it is enough to drive an external FPGA connected over UART, SPI, Ethernet, PCIe or whatever
        - Learn how to setup project properly, Python packages, C/C++ libaries, static linking, dynamic linking, etc.
    - Learn to write enough Embedded C to do some stuff on an FPGA+ARM SoC
        - Learn to use Make or CMake or similar

Electrical Design
    - Know how to read schematics even if you don't know how to design a PCB.
    - Learning to design simple PCBs while you are in school probably not a bad idea. Depending on the job you might have to interact with the people designing a custom board for you. Knowing their challenges can really help the process.

Application Skills
    - DSP
        - Learn to script stuff like filter tap generation for FIR filters
        - Learn to write a modulator and demodulator
        - Learn to write a FEC encoder or decoder
        - Learn what IQ samples are and why complex numbers are important
    - Image Processing
        - Learn how to do things like 2D convolution
        - Learn how to buffer lines
        - Learn to handle edge cases on the edge of the screen
    - DSP/Image Processing
        - Learn when it makes sense to consider tools like Simulink HDL Coder
    - Networking
        - Learn how to process Ethernet packets with their headers in FPGA
        - Learn to use WireShark
        - Understand IP frames, UDP frames well
</code></pre>
<p>And from ChatGPT, with an added emphasis on HFT applications:</p>
<pre><code>Certainly! Here are detailed topics to learn for each section of the learning plan:

1. Foundation in Electrical Engineering or Computer Science:
  - Digital logic design: Boolean algebra, logic gates, truth tables, Karnaugh maps.
  - Computer architecture: CPU organization, memory hierarchy, I/O systems.
  - Programming languages: C/C++, Python, data structures, algorithms.
  - Mathematics: Discrete mathematics, linear algebra, probability theory.

2. Digital Design and FPGA Programming:
  - Combinational and sequential circuits: Multiplexers, decoders, encoders, flip-flops, counters, shift registers.
  - Hardware description languages (HDL): VHDL or Verilog syntax, data types, modules, signals, processes, simulation.
  - Testbench creation and functional verification of digital designs.
  - FPGA-specific concepts: Lookup tables (LUTs), flip-flops, IOBs (input/output blocks), clocks, clock domains.

3. High-Frequency Trading Fundamentals:
  - Introduction to financial markets: Stocks, bonds, futures, options, derivatives.
  - Trading strategies: Market making, statistical arbitrage, momentum trading, mean reversion.
  - Order types and execution mechanisms: Limit orders, market orders, stop orders, iceberg orders, order routing.
  - Market data and order book management: Tick data, level 2 data, order matching algorithms, order book modeling.
  - Latency and high-speed data communication: Network protocols (TCP/IP, UDP), hardware acceleration, field-programmable gate arrays (FPGAs) for low-latency trading.

4. FPGA Development Tools:
  - Xilinx Vivado or Intel Quartus Prime: Project creation, synthesis, place and route, timing analysis.
  - Design constraints: Clock constraints, input/output constraints, area constraints.
  - Advanced FPGA features: Clock domain crossing (CDC), clock skew, metastability, floorplanning, power analysis.

5. Low-Level Programming:
  - C/C++ programming: Pointers, memory management, data structures, algorithms.
  - Optimization techniques: Loop unrolling, loop pipelining, loop fusion, cache optimization, vectorization.
  - Parallel programming: Multithreading, SIMD (Single Instruction Multiple Data), GPU programming (CUDA/OpenCL).

6. FPGA Design Skills:
  - Digital signal processing (DSP) on FPGAs: Filters, FFT (Fast Fourier Transform), digital modulation/demodulation.
  - Real-time data processing: Pipelining, streaming data, data buffering techniques.
  - High-speed data communication: Ethernet, TCP/IP, UDP, FPGA-based network interface cards (NICs).

7. FPGA-Based Trading Systems:
  - HFT system architectures: Market data handlers, order execution engines, risk management systems.
  - Design patterns: Finite state machines (FSMs), clock domain crossing (CDC) techniques, data serialization.
  - Latency optimization techniques: Hardware acceleration, pre-trade risk checks, order book modeling.
  - FPGA and CPU interaction: DMA (Direct Memory Access), PCIe (Peripheral Component Interconnect Express) communication, memory-mapped I/O.

8. Technology and Industry Trends:
  - FPGA advancements: New FPGA families and architectures (e.g., Xilinx UltraScale, Intel Stratix), high-level synthesis (HLS), partial reconfiguration.
  - High-frequency trading research and publications: Academic papers on trading algorithms, latency optimization, market microstructure.
  - Industry news and blogs: Stay updated on FPGA-related news, algorithmic trading strategies, and HFT regulations.

9. Internship or Job Opportunities:
  - Apply theoretical knowledge to real-world projects in FPGA development or high-frequency trading.
  - Collaborate with experienced engineers, learn from their expertise, and gain practical insights.
</code></pre>
]]></content></item></channel></rss>